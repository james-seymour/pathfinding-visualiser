{"version":3,"sources":["algorithms/algorithms.js","algorithms/dijkstra.js","visualiser/Node.js","visualiser/Visualiser.js","algorithms/dfs.js","App.js","index.js"],"names":["sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbours","node","grid","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","previousNode","neighbours","row","col","push","length","filter","isVisited","calculateDijkstra","startNode","endNode","visitedNodesInOrder","gridNodes","oneDimensionaliseGridNodes","closestNode","shift","isWall","Infinity","algorithmCalculation","endNodeReachable","Node","id","this","props","nodeData","className","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","PureComponent","Visualiser","createNode","state","START_NODE_ROW","START_NODE_COL","END_NODE_ROW","END_NODE_COL","distanceToFinishNode","Math","abs","createGridData","initialGrid","NUM_ROWS","currentRow","NUM_COLS","getStartNode","gridDataCopy","getEndNode","syncHTMLwithGridData","syncedGrid","getNodeClassName","animateAlgorithm","i","setTimeout","updateNodeClassName","setState","isRunning","gridData","animateShortestPath","resetElementInGrid","nodeClass","floor","window","screen","height","width","userPaintingWalls","userMovingStartNode","userMovingEndNode","isStartNode","isFinishNode","isWallNode","currentCol","document","getElementById","console","log","algorithm","dfsCalculation","finishNode","nextNodesStack","currentNode","pop","nextNode","dfs","map","rowData","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","href","onClick","parseAlgorithmChoice","clearWalls","clearAlgorithmSteps","clearEntireCanvas","renderUserInterface","renderGrid","Component","App","documentElement","style","setProperty","body","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2e902b94.chunk.js","sourcesContent":["// Shared functions for algorithm calculations\r\n\r\nconst oneDimensionaliseGridNodes = (grid) => {\r\n  const gridNodes = []\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      gridNodes.push(node)\r\n    }\r\n  }\r\n  return gridNodes\r\n}\r\n\r\nconst sortNodesByDistance = (unvisitedNodes) => {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nconst updateUnvisitedNeighbours = (node, grid) => {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid)\r\n  for (const neighbour of unvisitedNeighbours) {\r\n    neighbour.distance = node.distance + 1\r\n    neighbour.previousNode = node\r\n  }\r\n}\r\n\r\nconst getUnvisitedNeighbours = (node, grid) => {\r\n  const neighbours = []\r\n  const {row, col} = node\r\n  if (row > 0) neighbours.push(grid[row - 1][col])\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n  if (col > 0) neighbours.push(grid[row][col - 1])\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n  return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nexport { oneDimensionaliseGridNodes, sortNodesByDistance, updateUnvisitedNeighbours, getUnvisitedNeighbours }","// Main Dijkstra algorithm file\r\n\r\nimport { oneDimensionaliseGridNodes, sortNodesByDistance, updateUnvisitedNeighbours, getUnvisitedNeighbours } from \"./algorithms\"\r\n\r\n/* Probably rework this bit because I'm not sure how efficient it is to run the entire simulation first,\r\nand only then animate everything. If you wanna try it like this, then each node in the board data would\r\nhave to have some integer associated with it in the order that the algorithm progresses.\r\nYou could then iterate over these integers in the animate function to animate its probably more\r\nefficient to run it in real time. It might be cool to do it this way if there was a skip animation button \r\nthat just solved it straight away. \r\n\r\nMaybe a better alternative is to call the updateGridData method in a loop with a timeout to animate.\r\n\r\nBasically the goal is to only re-render the HTML element that is currently working instead of the entire board on every render.\r\nI think react should handle this because we set a key for each \r\n*/\r\n\r\n\r\nconst calculateDijkstra = (grid, startNode, endNode) => {\r\n    const visitedNodesInOrder = []\r\n    startNode.distance = 0\r\n    const unvisitedNodes = oneDimensionaliseGridNodes(grid)\r\n\r\n    while(!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes)\r\n        const closestNode = unvisitedNodes.shift()\r\n\r\n        if (closestNode.isWall) continue;\r\n        if (closestNode.distance === Infinity) return { algorithmCalculation: visitedNodesInOrder, endNodeReachable: false  };\r\n\r\n        closestNode.isVisited = true\r\n        visitedNodesInOrder.push(closestNode)\r\n\r\n        if (closestNode === endNode) return { algorithmCalculation: visitedNodesInOrder, endNodeReachable: true };\r\n\r\n        updateUnvisitedNeighbours(closestNode, grid)\r\n    }\r\n\r\n}\r\n\r\n\r\nexport { calculateDijkstra }","import React, { useState, PureComponent } from 'react'\r\nimport \"./Node.css\"\r\n\r\nexport default class Node extends PureComponent {\r\n  render() {\r\n\t\t// console.log(\"re-rendering\")\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tid={`node-${this.props.nodeData.row}-${this.props.nodeData.col}`}\r\n\t\t\t\tclassName={`node ${this.props.nodeData.isFinish ? 'node-finish' : this.props.nodeData.isStart ? 'node-start' : ''}`}\r\n\t\t\t\tonMouseDown={() => this.props.onMouseDown(this.props.nodeData.row, this.props.nodeData.col)}\r\n\t\t\t\tonMouseEnter={() => this.props.onMouseEnter(this.props.nodeData.row, this.props.nodeData.col)}\r\n\t\t\t\tonMouseUp={() => this.props.onMouseUp()}\r\n\t\t\t\t\r\n\t\t\t\t></div>\r\n\t\t)\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","import React, { Component, createContext, useState, useEffect } from 'react'\r\nimport { calculateDijkstra } from '../algorithms/dijkstra.js'\r\nimport { dfs } from \"../algorithms/dfs.js\"\r\nimport Node from \"./Node.js\"\r\nimport \"./Visualiser.css\" \r\n\r\n// Any {} tells the compiler this is JS specific code \r\n\r\nexport default class Visualiser extends Component {\r\n\tconstructor() {\r\n\t\tsuper();\r\n    this.state = {\r\n      gridData: [],\r\n      START_NODE_ROW: Math.floor((window.screen.height / 200) - 1),\r\n\t\t\tSTART_NODE_COL: Math.floor((window.screen.width / 300) - 1),\r\n      END_NODE_ROW: Math.floor((window.screen.height * 3 / 200)),\r\n      END_NODE_COL: Math.floor((window.screen.width * 5 / 300)),\r\n      userPaintingWalls: false,\r\n\t\t\tuserMovingStartNode: false,\r\n\t\t\tuserMovingEndNode: false,\r\n      NUM_ROWS: Math.floor(((window.screen.height - 250) / 30)),\r\n      NUM_COLS: Math.floor(((window.screen.width - 100) / 30)),\r\n\t\t\t// NUM_ROWS: 15,\r\n      // NUM_COLS: 25,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false,\r\n      currentRow: 0,\r\n      currentCol: 0,\r\n    };\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tconst gridData = this.createGridData()\r\n\t\tthis.setState({ gridData })\r\n\t}\r\n\t\r\n\tcreateNode = (row, col, isWall=false) => {\r\n\t\treturn ({\r\n\t\t\trow,\r\n\t\t\tcol,\r\n\t\t\tisStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n\t\t\tisFinish: row === this.state.END_NODE_ROW && col === this.state.END_NODE_COL,\r\n\t\t\tisWall: isWall,\r\n\t\t\tdistance: Infinity,\r\n\t\t\tdistanceToFinishNode: \r\n\t\t\t\tMath.abs(this.state.END_NODE_ROW - row) +\r\n\t\t\t\tMath.abs(this.state.END_NODE_COL - col), \r\n\t\t\tisVisited: false,\r\n\t\t\tpreviousNode: null,\r\n\t\t})\r\n\t}\r\n\r\n\tcreateGridData = () => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < this.state.NUM_ROWS; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < this.state.NUM_COLS; col++) {\r\n        currentRow.push(this.createNode(row, col));\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  }\r\n\r\n\tgetStartNode = (gridDataCopy) => {\r\n\t\tconst startNode = gridDataCopy[this.state.START_NODE_ROW][this.state.START_NODE_COL]\r\n\t\treturn startNode\r\n\t}\r\n\t\r\n\tgetEndNode = (gridDataCopy) => {\r\n\t\tconst endNode = gridDataCopy[this.state.END_NODE_ROW][this.state.END_NODE_COL]\r\n\t\treturn endNode\r\n\t}\r\n\r\n\tgetNodeClassName(row, col) {\r\n\t\treturn document.getElementById(`node-${row}-${col}`).className\r\n\t}\r\n\r\n\tupdateNodeClassName(row, col, className) {\r\n\t\tdocument.getElementById(`node-${row}-${col}`).className = `node ${className}`\r\n\t}\r\n\r\n\thandleMouseDown(row, col) {\r\n\t\tconsole.log(this.state)\r\n\t\tif (this.state.isRunning) return;\r\n\t\t\r\n\t\tif (this.state.START_NODE_ROW === row && this.state.START_NODE_COL === col) {\r\n\t\t\tthis.setState({ userMovingStartNode: true })\r\n\t\t} else if (this.state.END_NODE_ROW === row && this.state.END_NODE_COL === col) {\r\n\t\t\tthis.setState({ userMovingEndNode: true })\r\n\t\t} else {\r\n\t\t\tthis.setState({ userPaintingWalls: true })\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-wall')\r\n\t\t}\r\n\t}\r\n\t\r\n\thandleMouseEnter(row, col) {\r\n\t\tconst startNode = this.state.START_NODE_ROW === row && this.state.START_NODE_COL === col\r\n\t\tconst endNode = this.state.END_NODE_ROW === row && this.state.END_NODE_COL === col\r\n\t\tif (this.state.isRunning || startNode || endNode) return;\r\n\t\t\r\n\t\tif (this.state.userMovingStartNode) {\r\n\t\t\tthis.updateNodeClassName(this.state.START_NODE_ROW, this.state.START_NODE_COL, '')\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-start')\r\n\t\t\tthis.setState({ START_NODE_ROW: row, START_NODE_COL: col })\r\n\t\t} else if (this.state.userMovingEndNode) {\r\n\t\t\tthis.updateNodeClassName(this.state.END_NODE_ROW, this.state.END_NODE_COL, '')\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-finish')\r\n\t\t\tthis.setState({ END_NODE_ROW: row, END_NODE_COL: col })\r\n\t\t} else if (this.state.userPaintingWalls) {\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-wall')\r\n\t\t}\r\n\t}\r\n\t\r\n\thandleMouseUp() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.setState({ userMovingStartNode: false, userMovingEndNode: false, userPaintingWalls: false })\r\n\t\tthis.syncHTMLwithGridData(this.state.gridData)\r\n\t}\r\n\t\r\n\tsyncHTMLwithGridData = () => {\r\n\t\tconst syncedGrid = []\r\n\t\tfor (let row = 0; row < this.state.NUM_ROWS; row++) {\r\n\t\t\tconst currentRow = []\r\n\t\t\tfor (let col = 0; col < this.state.NUM_COLS; col++) {\r\n\t\t\t\tif (this.getNodeClassName(row, col) === 'node node-wall') {\r\n\t\t\t\t\tcurrentRow.push(this.createNode(row, col, true))\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentRow.push(this.createNode(row, col))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsyncedGrid.push(currentRow)\r\n\t\t}\r\n\t\treturn syncedGrid\r\n\t}\r\n\r\n\ttoggleIsRunning() {\r\n\t\tthis.setState({isRunning: !this.state.isRunning})\r\n\t}\r\n\r\n\tparseAlgorithmChoice(algorithm) {\r\n\t\tif (this.state.isRunning) return;\r\n\t\t// Set the state to running!\r\n\t\tthis.setState({isRunning: true})\r\n\t\tthis.resetElementInGrid('node-wall')\r\n\r\n\t\t// Grab some variables that each algorithm needs\r\n\t\tconst syncedGrid = this.syncHTMLwithGridData()\r\n\t\tconst startNode = this.getStartNode(syncedGrid)\r\n\t\tconst endNode = this.getEndNode(syncedGrid)\r\n\r\n\r\n\t\tswitch(algorithm) {\r\n\t\t\t// Add more cases on here for more implementations\r\n\t\t\t// Visualiser algorithms do not need the current state of the gridData\r\n\t\t\t// because they can actually receive this state by calling the update function\r\n\t\t\t// See dijkstra.js\r\n\t\t\tcase \"dijkstra\":\r\n\t\t\t\tconst { algorithmCalculation, endNodeReachable } = calculateDijkstra(syncedGrid, startNode, endNode)\r\n\t\t\t\tthis.animateAlgorithm(algorithmCalculation)\r\n\t\t\t\t// if (endNodeReachable) {this.animateShortestPath(dijkstraCalculation)}\r\n\t\t\t\tbreak;\r\n\t\t\t\r\n\t\t\tcase \"A*\":\r\n\t\t\t\tconst dfsCalculation = dfs(syncedGrid, startNode, endNode)\r\n\t\t\t\tthis.animateAlgorithm(dfsCalculation)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tanimateAlgorithm = (algorithmCalculation) => {\r\n\t\tfor (let i = 1; i < algorithmCalculation.length - 1; i++) {\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tconst node = algorithmCalculation[i]\r\n\t\t\t\tthis.updateNodeClassName(node.row, node.col, 'node-visited')\r\n\t\t\t}, 10 * i)\r\n\t\t}\r\n\t\tsetTimeout(() => {\r\n\t\t\tthis.setState({isRunning: false})\r\n\t\t}, 10 * (algorithmCalculation.length + 1))\r\n\t\tthis.setState({gridData: this.syncHTMLwithGridData()})\r\n\t}\r\n\r\n\tanimateShortestPath = (algorithmCalculation) => {\r\n\r\n\t}\r\n\r\n\t// if (node.isStart || node.isFinish || \r\n\t// \tthis.getNodeClassName(row, col) === `node ${filter}`) continue;\r\n\t// else {this.updateNodeClassName(row, col, '')}\r\n\r\n\tresetElementInGrid = (className) => {\r\n\t\tfor (let row = 0; row < this.state.NUM_ROWS; row++) {\r\n\t\t\tfor (let col = 0; col < this.state.NUM_COLS; col++) {\r\n\t\t\t\tconst nodeClass = this.getNodeClassName(row, col)\r\n\t\t\t\tif (nodeClass !== `node ${className}` && nodeClass !== 'node node-start' && nodeClass !== 'node node-finish') {\r\n\t\t\t\t\tthis.updateNodeClassName(row, col, '')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tclearWalls() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.resetElementInGrid('node-visited')\r\n\t}\r\n\r\n\tclearAlgorithmSteps() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.resetElementInGrid('node-wall')\r\n\t}\r\n\r\n\tclearEntireCanvas() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.setState({gridData: this.createGridData()})\r\n\t\tthis.resetElementInGrid('')\r\n\t}\r\n\r\n\trenderGrid() {\r\n\t\tconst gridData = this.state.gridData\r\n\t\treturn (\r\n\t\t\t// We want to render our <Node /> components here using the a Board Model\r\n\t\t\t<div className=\"grid\">\r\n\t\t\t\t{gridData.map((rowData, rowIndex) => {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<div key={rowIndex} className={`row row-${rowIndex}`}>\r\n\t\t\t\t\t\t\t{rowData.map((node, nodeIndex) => {\r\n\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t<Node \r\n\t\t\t\t\t\t\t\t\tkey={nodeIndex} \r\n\t\t\t\t\t\t\t\t\tnodeData={node}\r\n\t\t\t\t\t\t\t\t\tonMouseDown={(row, col) => {this.handleMouseDown(row, col)}}\r\n\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) => {this.handleMouseEnter(row, col)}}\r\n\t\t\t\t\t\t\t\t\tonMouseUp={() => {this.handleMouseUp()}}\r\n\t\t\t\t\t\t\t\t\t/>\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t)\r\n\t\t\t\t})}\r\n\t\t\t</div>\r\n\t\t)\r\n\t}\r\n\r\n\trenderUserInterface() {\r\n\t\treturn (\r\n\t\t\t<div className=\"userinterface\">\r\n\t\t\t\t<div className=\"userinterface-header\">\r\n\t\t\t\t\t<a id=\"homepageRefresh\" className=\"navbar\" href=\"\">\r\n\t\t\t\t\t\tPathfinding Visualiser\r\n\t\t\t\t\t</a>\r\n\t\t\t\t\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className=\"dropdown\">\r\n\t\t\t\t\t<button className=\"dropbtn\">Run an Algorithm!</button>\r\n\t\t\t\t\t<div className=\"dropdown-content\">\r\n\t\t\t\t\t\t<button id=\"Dijkstra\" className=\"button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.parseAlgorithmChoice(\"dijkstra\")}>\r\n\t\t\t\t\t\t\tDjikstra's Algorithm\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button id=\"AStar\" className=\"button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.parseAlgorithmChoice(\"A*\")}>\r\n\t\t\t\t\t\t\tA* Search\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button id=\"Greedy\" className=\"button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.parseAlgorithmChoice(\"greedy\")}>\r\n\t\t\t\t\t\t\tRun Greedy Best-First Search\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button id=\"Swarm\" className=\"button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.parseAlgorithmChoice(\"swarm\")}>\r\n\t\t\t\t\t\t\tRun Swarm Algorithm\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<button id=\"clear-walls\" className=\"button clear-button\"\r\n\t\t\t\tonClick={() => this.clearWalls()}>\r\n\t\t\t\t\tClear Placed Walls!\r\n\t\t\t\t</button>\r\n\t\t\t\t<button id=\"clear-algorithm-steps\" className=\"button clear-button\"\r\n\t\t\t\tonClick={() => this.clearAlgorithmSteps()}>\r\n\t\t\t\t\tClear Visited Nodes!\r\n\t\t\t\t</button>\r\n\t\t\t\t<button id=\"clear-board\" className=\"button clear-button\"\r\n\t\t\t\tonClick={() => this.clearEntireCanvas()}>\r\n\t\t\t\t\tClear the Entire Board!\r\n\t\t\t\t</button>\r\n\t\t\t</div>\r\n\r\n\t\t)\r\n\t}\r\n\r\n\t// Main Render State\r\n\trender() {\r\n\t\treturn (\t\t\r\n\t\t\t<>\r\n\t\t\t{this.renderUserInterface()}\r\n\t\t\t{this.renderGrid()}\r\n\t\t\t<div className=\"footer\">\r\n\t\t\t\tCreated by James Seymour. Check out my other projects on my Github <a href=\"https://github.com/james-seymour\">here</a>\r\n\t\t\t</div>\r\n\t\t\t</>\r\n\t\t)\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","export function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}","import React, { useState } from \"react\"\r\nimport Visualiser from \"./visualiser/Visualiser.js\"\r\nimport \"./App.css\"\r\n\r\nfunction App() {\r\n  // Do some really hacky tricks to properly set css\r\n  document.documentElement.style.setProperty(\"--screen-x\", Math.floor(((window.screen.width - 100) / 30)))\r\n  document.body.style = 'background-color: rgb(151, 143, 213);'\r\n  // In order to return more than one HTML element at once, wrap in an empty element:\r\n  return (\r\n      <div className=\"main\">  \r\n        <Visualiser />\r\n      </div>\r\n  )\r\n}\r\n\r\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n"],"sourceRoot":""}