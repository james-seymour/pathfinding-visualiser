{"version":3,"sources":["algorithms/algorithms.js","algorithms/dijkstra.js","visualiser/Node.js","visualiser/Visualiser.js","mazes/randmaze.js","algorithms/dfs.js","App.js","index.js"],"names":["sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbours","node","grid","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","previousNode","neighbours","row","col","push","length","filter","isVisited","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","calculateDijkstra","startNode","endNode","visitedNodesInOrder","gridNodes","oneDimensionaliseGridNodes","closestNode","shift","isWall","Infinity","Node","id","this","props","nodeData","className","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","PureComponent","Visualiser","createNode","state","START_NODE_ROW","START_NODE_COL","END_NODE_ROW","END_NODE_COL","distanceToFinishNode","Math","abs","createGridData","initialGrid","NUM_ROWS","currentRow","NUM_COLS","getStartNode","gridDataCopy","getEndNode","isStartNode","isEndNode","isStartOrEndNode","syncHTMLwithGridData","syncedGrid","getNodeClassName","resetElementInGrid","nodeClass","updateNodeClassName","generateRandomMaze","modifier","isRunning","clearWalls","randomIndices","rowCount","colCount","random","wallIndex","generateRandomMazeIndices","index","updateAnimationSpeed","label","timing","setState","animationSpeed","animationSpeedLabel","toggleVisitedNodesVisibility","nodesVisible","variableNumRows","floor","window","screen","height","variableNumCols","width","variableDefaultStartingPos","variableDefaultEndingPos","gridData","userPaintingWalls","userMovingStartNode","userMovingEndNode","isFinishNode","isWallNode","currentCol","selectedAlgorithm","document","getElementById","dijkstraCalculation","dijkstraShortestPath","animateAlgorithm","dfsCalculation","nextNodesStack","pop","nextNode","dfs","dfsShortestPath","i","setTimeout","animateShortestPath","animationTime","href","onClick","clearAlgorithmSteps","clearEntireCanvas","type","parseAlgorithmChoice","map","rowData","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","renderUserInterface","renderLegend","renderGrid","Component","App","documentElement","style","setProperty","body","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.481676d2.chunk.js","sourcesContent":["// Shared functions for algorithm calculations\r\n\r\nconst oneDimensionaliseGridNodes = (grid) => {\r\n  const gridNodes = []\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      gridNodes.push(node)\r\n    }\r\n  }\r\n  return gridNodes\r\n}\r\n\r\nconst sortNodesByDistance = (unvisitedNodes) => {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nconst updateUnvisitedNeighbours = (node, grid) => {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid)\r\n  for (const neighbour of unvisitedNeighbours) {\r\n    neighbour.distance = node.distance + 1\r\n    neighbour.previousNode = node\r\n  }\r\n}\r\n\r\nconst getUnvisitedNeighbours = (node, grid) => {\r\n  const neighbours = []\r\n  const {row, col} = node\r\n  if (row > 0) neighbours.push(grid[row - 1][col])\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n  if (col > 0) neighbours.push(grid[row][col - 1])\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n  return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nconst getNodesInShortestPathOrder = (finishNode) => {\r\n  const nodesInShortestPathOrder = []\r\n  let currentNode = finishNode\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode)\r\n    currentNode = currentNode.previousNode\r\n  }\r\n  return nodesInShortestPathOrder\r\n}\r\n\r\nexport { oneDimensionaliseGridNodes, sortNodesByDistance, updateUnvisitedNeighbours, getUnvisitedNeighbours, getNodesInShortestPathOrder }","// Main Dijkstra algorithm file\r\n\r\nimport { oneDimensionaliseGridNodes, sortNodesByDistance, updateUnvisitedNeighbours, getUnvisitedNeighbours, getNodesInShortestPathOrder } from \"./algorithms.js\"\r\n\r\n/* Probably rework this bit because I'm not sure how efficient it is to run the entire simulation first,\r\nand only then animate everything. If you wanna try it like this, then each node in the board data would\r\nhave to have some integer associated with it in the order that the algorithm progresses.\r\nYou could then iterate over these integers in the animate function to animate its probably more\r\nefficient to run it in real time. It might be cool to do it this way if there was a skip animation button \r\nthat just solved it straight away. \r\n\r\nMaybe a better alternative is to call the updateGridData method in a loop with a timeout to animate.\r\n\r\nBasically the goal is to only re-render the HTML element that is currently working instead of the entire board on every render.\r\nI think react should handle this because we set a key for each \r\n*/\r\n\r\n\r\nconst calculateDijkstra = (grid, startNode, endNode) => {\r\n    const visitedNodesInOrder = []\r\n    startNode.distance = 0\r\n    const unvisitedNodes = oneDimensionaliseGridNodes(grid)\r\n\r\n    while(!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes)\r\n        const closestNode = unvisitedNodes.shift()\r\n\r\n        if (closestNode.isWall) continue;\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n\r\n        closestNode.isVisited = true\r\n        visitedNodesInOrder.push(closestNode)\r\n\r\n        if (closestNode === endNode) return visitedNodesInOrder;\r\n\r\n        updateUnvisitedNeighbours(closestNode, grid)\r\n    }\r\n\r\n}\r\n\r\n\r\nexport { calculateDijkstra }","import React, { useState, PureComponent } from 'react'\r\nimport \"./Node.css\"\r\n\r\nexport default class Node extends PureComponent {\r\n  render() {\r\n\t\t// console.log(\"re-rendering\")\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tid={`node-${this.props.nodeData.row}-${this.props.nodeData.col}`}\r\n\t\t\t\tclassName={`node ${this.props.nodeData.isFinish ? 'node-finish' : this.props.nodeData.isStart ? 'node-start' : ''}`}\r\n\t\t\t\tonMouseDown={() => this.props.onMouseDown(this.props.nodeData.row, this.props.nodeData.col)}\r\n\t\t\t\tonMouseEnter={() => this.props.onMouseEnter(this.props.nodeData.row, this.props.nodeData.col)}\r\n\t\t\t\tonMouseUp={() => this.props.onMouseUp()}\r\n\t\t\t\t\r\n\t\t\t\t></div>\r\n\t\t)\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","import React, { Component, createContext, useState, useEffect } from 'react'\r\nimport { calculateDijkstra } from '../algorithms/dijkstra.js'\r\nimport { dfs } from \"../algorithms/dfs.js\"\r\nimport Node from \"./Node.js\"\r\nimport \"./Visualiser.css\" \r\nimport { getNodesInShortestPathOrder } from '../algorithms/algorithms.js'\r\nimport { generateRandomMazeIndices } from '../mazes/randmaze.js'\r\n\r\n// Any {} tells the compiler this is JS specific code \r\n\r\nexport default class Visualiser extends Component {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tconst variableNumRows = Math.floor(((window.screen.height - 350) / 25))\r\n\t\tconst variableNumCols = Math.floor(((window.screen.width - 200) / 25))\r\n\t\tconst variableDefaultStartingPos = [Math.floor(variableNumRows/4) - 1, Math.floor(variableNumCols/4) - 1]\r\n\t\tconst variableDefaultEndingPos = [Math.floor(3*variableNumRows/4), Math.floor(3*variableNumCols/4)]\r\n\r\n    this.state = {\r\n      gridData: [],\r\n      START_NODE_ROW: variableDefaultStartingPos[0],\r\n\t\t\tSTART_NODE_COL: variableDefaultStartingPos[1],\r\n      END_NODE_ROW: variableDefaultEndingPos[0],\r\n      END_NODE_COL: variableDefaultEndingPos[1],\r\n      userPaintingWalls: false,\r\n\t\t\tuserMovingStartNode: false,\r\n\t\t\tuserMovingEndNode: false,\r\n      NUM_ROWS: variableNumRows,\r\n      NUM_COLS: variableNumCols,\r\n\t\t\t// NUM_ROWS: 15,\r\n      // NUM_COLS: 25,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false,\r\n      currentRow: 0,\r\n      currentCol: 0,\r\n\t\t\tselectedAlgorithm: null,\r\n\t\t\tanimationSpeed: 5,\r\n\t\t\tanimationSpeedLabel: \"Fast\",\r\n\t\t\tnodesVisible: false\r\n    };\r\n\t}\r\n\r\n\t//Main purple colour: rgb(151, 143, 213)\r\n\r\n\tcomponentDidMount() {\r\n\t\tconst gridData = this.createGridData()\r\n\t\tthis.setState({ gridData })\r\n\t}\r\n\t\r\n\tcreateNode = (row, col, isWall=false) => {\r\n\t\treturn ({\r\n\t\t\trow,\r\n\t\t\tcol,\r\n\t\t\tisStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n\t\t\tisFinish: row === this.state.END_NODE_ROW && col === this.state.END_NODE_COL,\r\n\t\t\tisWall: isWall,\r\n\t\t\tdistance: Infinity,\r\n\t\t\tdistanceToFinishNode: \r\n\t\t\t\tMath.abs(this.state.END_NODE_ROW - row) +\r\n\t\t\t\tMath.abs(this.state.END_NODE_COL - col), \r\n\t\t\tisVisited: false,\r\n\t\t\tpreviousNode: null,\r\n\t\t})\r\n\t}\r\n\r\n\tcreateGridData = () => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < this.state.NUM_ROWS; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < this.state.NUM_COLS; col++) {\r\n        currentRow.push(this.createNode(row, col));\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  }\r\n\r\n\tgetStartNode = (gridDataCopy) => {\r\n\t\tconst startNode = gridDataCopy[this.state.START_NODE_ROW][this.state.START_NODE_COL]\r\n\t\treturn startNode\r\n\t}\r\n\t\r\n\tgetEndNode = (gridDataCopy) => {\r\n\t\tconst endNode = gridDataCopy[this.state.END_NODE_ROW][this.state.END_NODE_COL]\r\n\t\treturn endNode\r\n\t}\r\n\r\n\tisStartNode = (row, col) => {\r\n\t\treturn (row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL)\r\n\t}\r\n\r\n\tisEndNode = (row, col) => {\r\n\t\treturn (row === this.state.END_NODE_ROW && col === this.state.END_NODE_COL)\r\n\t}\r\n\r\n\tisStartOrEndNode = (row, col) => {\r\n\t\treturn (this.isStartNode(row, col) || this.isEndNode(row, col))\r\n\t}\r\n\r\n\tgetNodeClassName(row, col) {\r\n\t\treturn document.getElementById(`node-${row}-${col}`).className\r\n\t}\r\n\r\n\tupdateNodeClassName(row, col, className) {\r\n\t\tdocument.getElementById(`node-${row}-${col}`).className = `node ${className}`\r\n\t}\r\n\r\n\thandleMouseDown(row, col) {\r\n\t\tif (this.state.isRunning) return;\r\n\t\t\r\n\t\tif (this.isStartNode(row, col)) {\r\n\t\t\tthis.setState({ userMovingStartNode: true })\r\n\t\t} else if (this.isEndNode(row, col)) {\r\n\t\t\tthis.setState({ userMovingEndNode: true })\r\n\t\t} else {\r\n\t\t\tthis.setState({ userPaintingWalls: true })\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-wall')\r\n\t\t}\r\n\t}\r\n\t\r\n\thandleMouseEnter(row, col) {\r\n\t\tif (this.state.isRunning || this.isStartOrEndNode(row, col)) return;\r\n\t\t\r\n\t\tif (this.state.userMovingStartNode) {\r\n\t\t\tthis.updateNodeClassName(this.state.START_NODE_ROW, this.state.START_NODE_COL, '')\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-start')\r\n\t\t\tthis.setState({ START_NODE_ROW: row, START_NODE_COL: col })\r\n\t\t} else if (this.state.userMovingEndNode) {\r\n\t\t\tthis.updateNodeClassName(this.state.END_NODE_ROW, this.state.END_NODE_COL, '')\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-finish')\r\n\t\t\tthis.setState({ END_NODE_ROW: row, END_NODE_COL: col })\r\n\t\t} else if (this.state.userPaintingWalls) {\r\n\t\t\tthis.updateNodeClassName(row, col, 'node-wall')\r\n\t\t}\r\n\t}\r\n\t\r\n\thandleMouseUp() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.setState({ userMovingStartNode: false, userMovingEndNode: false, userPaintingWalls: false })\r\n\t\tthis.syncHTMLwithGridData(this.state.gridData)\r\n\t}\r\n\t\r\n\tsyncHTMLwithGridData = () => {\r\n\t\tconst syncedGrid = []\r\n\t\tfor (let row = 0; row < this.state.NUM_ROWS; row++) {\r\n\t\t\tconst currentRow = []\r\n\t\t\tfor (let col = 0; col < this.state.NUM_COLS; col++) {\r\n\t\t\t\tif (this.getNodeClassName(row, col) === 'node node-wall') {\r\n\t\t\t\t\tcurrentRow.push(this.createNode(row, col, true))\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentRow.push(this.createNode(row, col))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsyncedGrid.push(currentRow)\r\n\t\t}\r\n\t\treturn syncedGrid\r\n\t}\r\n\r\n\ttoggleIsRunning() {\r\n\t\tthis.setState({isRunning: !this.state.isRunning})\r\n\t}\r\n\r\n\tparseAlgorithmChoice() {\r\n\tif (this.state.isRunning) return;\r\n\t// Set the state to running!\r\n\tthis.setState({isRunning: true})\r\n\tthis.resetElementInGrid('node-wall')\r\n\r\n\t// Grab some variables that each algorithm needs\r\n\tconst syncedGrid = this.syncHTMLwithGridData()\r\n\tconst startNode = this.getStartNode(syncedGrid)\r\n\tconst endNode = this.getEndNode(syncedGrid)\r\n\r\n\tswitch(this.state.selectedAlgorithm) {\r\n\t\t// Add more cases on here for more implementations\r\n\t\t// Visualiser algorithms do not need the current state of the gridData\r\n\t\t// because they can actually receive this state by calling the update function\r\n\t\t// See dijkstra.js\r\n\t\tcase \"Dijkstra's Algorithm\":\r\n\t\t\tconst dijkstraCalculation = calculateDijkstra(syncedGrid, startNode, endNode)\r\n\t\t\tconst dijkstraShortestPath = getNodesInShortestPathOrder(endNode)\r\n\t\t\tthis.animateAlgorithm(dijkstraCalculation, dijkstraShortestPath)\r\n\t\t\t// if (endNodeReachable) {this.animateShortestPath(dijkstraCalculation)}\r\n\t\t\tbreak;\r\n\t\tcase \"A* Search\":\r\n\t\t\tconst dfsCalculation = dfs(syncedGrid, startNode, endNode)\r\n\t\t\tconst dfsShortestPath = getNodesInShortestPathOrder(endNode)\r\n\t\t\tthis.animateAlgorithm(dfsCalculation, dfsShortestPath)\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthis.setState({isRunning: false})\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    // Dfs currently not working when it cannot find the end node\r\n\t\tfor (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, this.state.animationSpeed * i);\r\n      } else {\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tconst node = visitedNodesInOrder[i];\r\n\t\t\t\t\tif (this.state.nodesVisible) {\r\n\t\t\t\t\t\tthis.updateNodeClassName(node.row, node.col, 'node node-visited-visible')\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.updateNodeClassName(node.row, node.col, 'node node-visited')\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this.state.animationSpeed * i);\r\n\t\t\t}\r\n    }\r\n\t\tconst animationTime = this.state.animationSpeed * (visitedNodesInOrder.length + 1) + 50 * (nodesInShortestPathOrder.length + 1)\r\n\t\tsetTimeout(() => {\r\n\t\t\tthis.setState({isRunning: false})\r\n\t\t}, animationTime)\r\n\t\tthis.setState({gridData: this.syncHTMLwithGridData()})\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-shortest-path';\r\n      }, this.state.animationSpeed * 6 * i);\r\n    }\r\n  }\r\n\r\n\t// if (node.isStart || node.isFinish || \r\n\t// \tthis.getNodeClassName(row, col) === `node ${filter}`) continue;\r\n\t// else {this.updateNodeClassName(row, col, '')}\r\n\r\n\tresetElementInGrid = (className) => {\r\n\t\tfor (let row = 0; row < this.state.NUM_ROWS; row++) {\r\n\t\t\tfor (let col = 0; col < this.state.NUM_COLS; col++) {\r\n\t\t\t\tconst nodeClass = this.getNodeClassName(row, col)\r\n\t\t\t\tif (nodeClass !== `node ${className}` && nodeClass !== 'node node-start' && nodeClass !== 'node node-finish') {\r\n\t\t\t\t\tthis.updateNodeClassName(row, col, '')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgenerateRandomMaze = (modifier) => {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.clearWalls()\r\n\t\tconst randomIndices = generateRandomMazeIndices(this.state.NUM_ROWS, this.state.NUM_COLS, modifier)\r\n\t\tfor (const index of randomIndices) {\r\n\t\t\tif (!this.isStartOrEndNode(index.row, index.col)) {\r\n\t\t\t\tthis.updateNodeClassName(index.row, index.col, 'node-wall')\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tupdateAnimationSpeed = (label, timing) => {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.setState({ animationSpeed: timing, animationSpeedLabel: label })\r\n\t}\r\n\r\n\tclearWalls() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.resetElementInGrid('node-visited')\r\n\t}\r\n\r\n\tclearAlgorithmSteps() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.resetElementInGrid('node-wall')\r\n\t}\r\n\r\n\tclearEntireCanvas() {\r\n\t\tif (this.state.isRunning) return;\r\n\t\tthis.setState({gridData: this.createGridData()})\r\n\t\tthis.resetElementInGrid('')\r\n\t}\r\n\r\n\ttoggleVisitedNodesVisibility = () => {\r\n\t\tthis.setState({ nodesVisible: !this.state.nodesVisible })\r\n\t}\r\n\r\n\trenderUserInterface() {\r\n\t\treturn (\r\n\t\t\t<div className=\"userinterface\">\r\n\t\t\t\t<a id=\"homepageRefresh\" className=\"navbar\" href=\"\">\r\n\t\t\t\t\tPathfinding Visualiser\r\n\t\t\t\t</a>\r\n\t\t\t\t<div className=\"dropdown\">\r\n\t\t\t\t\t<button className=\"button dropbtn\">Run an Algorithm!</button>\r\n\t\t\t\t\t<div className=\"dropdown-content\">\r\n\t\t\t\t\t\t<button id=\"Dijkstra\" className=\"dropdown-content-button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.setState({ selectedAlgorithm: \"Dijkstra's Algorithm\"})}>\r\n\t\t\t\t\t\t\tDjikstra's Algorithm\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button id=\"AStar\" className=\"dropdown-content-button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.setState({ selectedAlgorithm: \"A* Search\"})}>\r\n\t\t\t\t\t\t\tA* Search\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button id=\"Greedy\" className=\"dropdown-content-button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.setState({ selectedAlgorithm: \"Greedy Best-First Search\"})}>\r\n\t\t\t\t\t\t\tRun Greedy Best-First Search\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button id=\"Swarm\" className=\"dropdown-content-button algorithm-button\"\r\n\t\t\t\t\t\tonClick={() => this.setState({ selectedAlgorithm: \"Swarm Search\"})}>\r\n\t\t\t\t\t\t\tRun Swarm Algorithm\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className=\"dropdown\">\r\n\t\t\t\t\t<button className=\"button dropbtn\">Generate A Maze!</button>\r\n\t\t\t\t\t<div className=\"dropdown-content\">\r\n\t\t\t\t\t\t<button className=\"dropdown-content-button\" onClick={() => {this.generateRandomMaze(0.1)}}>\r\n\t\t\t\t\t\t\tSparse Random: (~10% Coverage)\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button className=\"dropdown-content-button\" onClick={() => {this.generateRandomMaze(0.2)}}>\r\n\t\t\t\t\t\t\tNormal Random: (~20% Coverage)\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button className=\"dropdown-content-button\" onClick={() => {this.generateRandomMaze(0.35)}}>\r\n\t\t\t\t\t\t\tDense Random: (~35% Coverage)\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t{/* Create more maze buttons here */}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className=\"dropdown\">\r\n\t\t\t\t\t<button className=\"button dropbtn\">Speed: {this.state.animationSpeedLabel}</button>\r\n\t\t\t\t\t<div className=\"dropdown-content\">\r\n\t\t\t\t\t\t<button className=\"dropdown-content-button\" onClick={() => {this.updateAnimationSpeed(\"Slow\", 20)}}>\r\n\t\t\t\t\t\t\tSlow\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button className=\"dropdown-content-button\" onClick={() => {this.updateAnimationSpeed(\"Medium\", 10)}}>\r\n\t\t\t\t\t\t\tMedium\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button className=\"dropdown-content-button\" onClick={() => {this.updateAnimationSpeed(\"Fast\", 5)}}>\r\n\t\t\t\t\t\t\tFast\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t<button className=\"dropdown-content-button\" onClick={() => {this.updateAnimationSpeed(\"Insane\", 1)}}>\r\n\t\t\t\t\t\t\tInsane\r\n\t\t\t\t\t\t</button>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<button id=\"clear-algorithm-steps\" className=\"button clear-button\"\r\n\t\t\t\tonClick={() => this.clearAlgorithmSteps()}>\r\n\t\t\t\t\tClear Visited Nodes!\r\n\t\t\t\t</button>\r\n\t\t\t\t<button id=\"clear-board\" className=\"button clear-button\"\r\n\t\t\t\tonClick={() => this.clearEntireCanvas()}>\r\n\t\t\t\t\tClear the Entire Board!\r\n\t\t\t\t</button>\r\n\t\t\t\t<div className=\"view-visited-container\" onMouseDown={() => this.toggleVisitedNodesVisibility()}>\r\n\t\t\t\t\t<label className=\"view-visited\">\r\n\t\t\t\t\t\t<input id=\"toggle-view-visited\" type=\"checkbox\"></input>\r\n\t\t\t\t\t\t<span className=\"checkmark\"></span>\r\n\t\t\t\t\t\tView Visited Nodes?\r\n\t\t\t\t\t</label>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\r\n\t\t)\r\n\t}\r\n\r\n\trenderLegend() {\r\n\t\treturn (\r\n\t\t\t<div className=\"legend\">\r\n\t\t\t\t<button className=\"visualise-button\" onClick={() => {this.parseAlgorithmChoice()}}>\r\n\t\t\t\t\t{this.state.selectedAlgorithm ? \r\n\t\t\t\t\t`Run ${this.state.selectedAlgorithm}!` : \r\n\t\t\t\t\t\"Choose a search method from the Run an Algorithm menu!\"}\r\n\t\t\t\t</button>\r\n\t\t\t\t\r\n\t\t\t\t</div>\r\n\t\t)\r\n\t}\r\n\r\n\trenderGrid() {\r\n\t\tconst gridData = this.state.gridData\r\n\t\treturn (\r\n\t\t\t// We want to render our <Node /> components here using the a Board Model\r\n\t\t\t<div className=\"grid\">\r\n\t\t\t\t{gridData.map((rowData, rowIndex) => {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<div key={rowIndex} className={`row row-${rowIndex}`}>\r\n\t\t\t\t\t\t\t{rowData.map((node, nodeIndex) => {\r\n\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t<Node \r\n\t\t\t\t\t\t\t\t\tkey={nodeIndex} \r\n\t\t\t\t\t\t\t\t\tnodeData={node}\r\n\t\t\t\t\t\t\t\t\tonMouseDown={(row, col) => {this.handleMouseDown(row, col)}}\r\n\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) => {this.handleMouseEnter(row, col)}}\r\n\t\t\t\t\t\t\t\t\tonMouseUp={() => {this.handleMouseUp()}}\r\n\t\t\t\t\t\t\t\t\t/>\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t)\r\n\t\t\t\t})}\r\n\t\t\t</div>\r\n\t\t)\r\n\t}\r\n\r\n\r\n\r\n\t// Main Render State\r\n\trender() {\r\n\t\treturn (\t\t\r\n\t\t\t<>\r\n\t\t\t{this.renderUserInterface()}\r\n\t\t\t{this.renderLegend()}\r\n\t\t\t{this.renderGrid()}\r\n\t\t\t<div className=\"footer\">\r\n\t\t\t\tCreated by James Seymour. The source code for this app and my other projects are on my Github <a className=\"github-link\" href=\"https://github.com/james-seymour\">here</a>\r\n\t\t\t</div>\r\n\t\t\t</>\r\n\t\t)\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","\r\n\r\nconst generateRandomMazeIndices = (rowCount, colCount, modifier) => {\r\n  const randomIndices = []\r\n  for (let row = 0; row < rowCount; row++) {\r\n    for (let col = 0; col < colCount; col++) {\r\n      if (Math.random() < modifier) {\r\n        const wallIndex = { row: row, col: col }\r\n        randomIndices.push(wallIndex)\r\n      }\r\n    } \r\n  }\r\n  return randomIndices\r\n}\r\n\r\nexport { generateRandomMazeIndices }","export function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}","import React, { useState } from \"react\"\r\nimport Visualiser from \"./visualiser/Visualiser.js\"\r\nimport \"./App.css\"\r\n\r\nfunction App() {\r\n  // Do some really hacky tricks to properly set css\r\n  document.documentElement.style.setProperty(\"--screen-x\", Math.floor(((window.screen.width - 100) / 30)))\r\n  document.body.style = 'background-color: rgb(42, 42, 42);'\r\n  // In order to return more than one HTML element at once, wrap in an empty element:\r\n  return (\r\n      <div className=\"main\">  \r\n        <Visualiser />\r\n      </div>\r\n  )\r\n}\r\n\r\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n"],"sourceRoot":""}